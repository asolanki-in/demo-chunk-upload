#!/bin/zsh
# Re-sign an iOS .ipa or .app WITHOUT changing Mach-O UUIDs (keeps original dSYMs valid).
# Works in zsh on macOS. Signs: main .app, Frameworks/*.framework, Frameworks/*.dylib, PlugIns/*.appex, Watch/*.app
# Repackages to .ipa (or outputs .app) as requested.

set -euo pipefail

# ---------- Usage ----------
if [[ $# -lt 4 ]]; then
  echo "Usage: $0 <CERTIFICATE_NAME> <PROVISIONING_PROFILE> <INPUT_IPA_OR_APP> <OUTPUT_IPA_OR_APP>"
  echo " Example:"
  echo "  $0 'Apple Distribution: Your Org' ./profile.mobileprovision ./Original.ipa ./Resigned.ipa"
  exit 1
fi

CERT="$1"
PROFILE="$2"
INPUT="$3"
OUTPUT="$4"

PLISTBUDDY="/usr/libexec/PlistBuddy"

# ---------- Workspace ----------
WORKDIR="$(mktemp -d)"
PAYLOADDIR="$WORKDIR/Payload"
mkdir -p "$PAYLOADDIR"

function cleanup {
  rm -rf "$WORKDIR"
}
trap cleanup EXIT

# ---------- Helpers ----------
# Return CFBundleExecutable full path for a .app/.appex bundle, or empty string.
bundle_exec_path() {
  local bundle="$1"
  local infoplist="$bundle/Info.plist"
  [[ -f "$infoplist" ]] || { echo ""; return 0; }
  local execname
  execname="$($PLISTBUDDY -c 'Print :CFBundleExecutable' "$infoplist" 2>/dev/null || true)"
  if [[ -n "${execname:-}" && -f "$bundle/$execname" ]]; then
    echo "$bundle/$execname"
  else
    echo ""
  fi
}

# Grab UUID lines for a Mach-O (fat or thin).
uuid_of() {
  local bin="$1"
  [[ -f "$bin" ]] || { echo ""; return 0; }
  # Format: "UUID: XXXXX (arm64) <name>" → we keep everything after "UUID:"
  dwarfdump --uuid "$bin" 2>/dev/null | awk '{$1=""; print substr($0,2)}'
}

# Dump current entitlements (if any) from a signed item to a temp file.
dump_entitlements() {
  local item="$1"
  local out="$2"
  if codesign -d --entitlements :- "$item" 2>/dev/null > "$out"; then
    [[ -s "$out" ]] || rm -f "$out"   # empty → no entitlements; remove file
  else
    rm -f "$out"
  fi
}

# Sign a single bundle or file WITHOUT touching code segment
sign_item() {
  local path="$1"
  local ent_tmp="$WORKDIR/ents.plist"

  # Remove previous signature for bundle dirs; replace embedded.profile for app/appex
  if [[ "$path" == *.app || "$path" == *.appex || "$path" == *.framework ]]; then
    rm -rf "$path/_CodeSignature" 2>/dev/null || true
    if [[ "$path" == *.app || "$path" == *.appex ]]; then
      cp -f "$PROFILE" "$path/embedded.mobileprovision"
    fi
  fi

  dump_entitlements "$path" "$ent_tmp"
  if [[ -f "$ent_tmp" ]]; then
    /usr/bin/codesign -f -s "$CERT" --timestamp=none --entitlements "$ent_tmp" "$path"
    rm -f "$ent_tmp"
  else
    /usr/bin/codesign -f -s "$CERT" --timestamp=none "$path"
  fi
}

# Walk and sign nested content in correct order (frameworks→extensions→watch→bundle)
sign_bundle_tree() {
  local appdir="$1"

  # 1) Frameworks & loose dylibs
  if [[ -d "$appdir/Frameworks" ]]; then
    # frameworks as bundles
    /usr/bin/find "$appdir/Frameworks" -type d -name "*.framework" -print0 | while IFS= read -r -d '' fw; do
      sign_item "$fw"
    done
    # loose dylibs (any executable file with any execute bit set)
    /usr/bin/find "$appdir/Frameworks" -type f \( -name "*.dylib" -o -perm -111 \) -print0 | while IFS= read -r -d '' dyl; do
      sign_item "$dyl"
    done
  fi

  # 2) App Extensions (sign their inner frameworks first, then the appex bundle)
  if [[ -d "$appdir/PlugIns" ]]; then
    /usr/bin/find "$appdir/PlugIns" -type d -name "*.appex" -print0 | while IFS= read -r -d '' appex; do
      sign_bundle_tree "$appex"
      sign_item "$appex"
    done
  fi

  # 3) Watch apps
  if [[ -d "$appdir/Watch" ]]; then
    /usr/bin/find "$appdir/Watch" -type d -name "*.app" -print0 | while IFS= read -r -d '' wapp; do
      sign_bundle_tree "$wapp"
      sign_item "$wapp"
    done
  fi
}

# Record UUIDs for bundle tree into an assoc array (path → uuid-lines)
typeset -A UUIDS_BEFORE
record_uuids_for_tree() {
  local root="$1"
  # main exec if present
  if [[ "$root" == *.app || "$root" == *.appex ]]; then
    local exe="$(bundle_exec_path "$root")"
    [[ -n "$exe" ]] && UUIDS_BEFORE["$exe"]="$(uuid_of "$exe")"
  fi
  # frameworks/dylibs
  if [[ -d "$root/Frameworks" ]]; then
    while IFS= read -r -d '' b; do
      UUIDS_BEFORE["$b"]="$(uuid_of "$b")"
    done < <(/usr/bin/find "$root/Frameworks" -type f \( -name "*.dylib" -o -perm -111 \) -print0)
  fi
  # recurse into appex & watch
  if [[ -d "$root/PlugIns" ]]; then
    while IFS= read -r -d '' appex; do
      record_uuids_for_tree "$appex"
    done < <(/usr/bin/find "$root/PlugIns" -type d -name "*.appex" -print0)
  fi
  if [[ -d "$root/Watch" ]]; then
    while IFS= read -r -d '' wapp; do
      record_uuids_for_tree "$wapp"
    done < <(/usr/bin/find "$root/Watch" -type d -name "*.app" -print0)
  fi
}

# ---------- Unpack input ----------
APPDIR=""
if [[ "$INPUT" == *.ipa ]]; then
  /usr/bin/unzip -q "$INPUT" -d "$WORKDIR"
  APPDIR="$(/usr/bin/find "$WORKDIR/Payload" -type d -name "*.app" | head -n1)"
  [[ -n "$APPDIR" ]] || { echo "Error: .app not found in IPA"; exit 1; }
elif [[ "$INPUT" == *.app ]]; then
  /bin/cp -R "$INPUT" "$PAYLOADDIR/"
  APPDIR="$(/usr/bin/find "$PAYLOADDIR" -type d -name "*.app" | head -n1)"
else
  echo "Error: INPUT must be .ipa or .app"; exit 1
fi

# ---------- UUIDs BEFORE ----------
record_uuids_for_tree "$APPDIR"

# ensure top-level embedded.mobileprovision uses the provided profile
/bin/cp -f "$PROFILE" "$APPDIR/embedded.mobileprovision"

# ---------- Sign nested → then the main app ----------
sign_bundle_tree "$APPDIR"
rm -rf "$APPDIR/_CodeSignature" 2>/dev/null || true
sign_item "$APPDIR"

# ---------- UUIDs AFTER + report ----------
echo
echo "=========== UUID CHECK (Before vs After) ==========="
local mismatch=0
for path in ${(k)UUIDS_BEFORE}; do
  local before="${UUIDS_BEFORE[$path]}"
  local after="$(uuid_of "$path")"
  echo "$path"
  echo "  BEFORE: $before"
  echo "  AFTER : $after"
  if [[ "$before" != "$after" ]]; then
    echo "  !!! MISMATCH"
    mismatch=1
  fi
done
echo "===================================================="
echo
if [[ $mismatch -ne 0 ]]; then
  echo "WARNING: One or more UUIDs changed. (This script never strips/thins; a change means the input was previously modified by some other tool.)"
else
  echo "Success: All UUIDs unchanged. Your original dSYM(s) will match."
fi
echo

# ---------- Output (.ipa or .app) ----------
if [[ "$OUTPUT" == *.ipa ]]; then
  # ensure Payload is at root
  if [[ ! -d "$WORKDIR/Payload" ]]; then
    mkdir -p "$WORKDIR/Payload"
    /bin/mv "$APPDIR" "$WORKDIR/Payload/"
  fi
  (cd "$WORKDIR" && /usr/bin/zip -qr "$OUTPUT" Payload)
  echo "Wrote IPA: $OUTPUT"
elif [[ "$OUTPUT" == *.app ]]; then
  /bin/cp -R "$APPDIR" "$OUTPUT"
  echo "Wrote app bundle: $OUTPUT"
else
  echo "Error: OUTPUT must be .ipa or .app"; exit 1
fi