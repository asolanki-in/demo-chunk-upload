// BiometricBypass.m
// Objective-C runtime hook for LAContext biometric bypass

#import <Foundation/Foundation.h>
#import <LocalAuthentication/LocalAuthentication.h>
#import <objc/runtime.h>

@interface BiometricBypass : NSObject
@end

@implementation BiometricBypass

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSLog(@"[BiometricBypass] Initializing biometric bypass framework...");
        
        Class laContextClass = NSClassFromString(@"LAContext");
        if (!laContextClass) {
            NSLog(@"[BiometricBypass] ERROR: LAContext class not found!");
            return;
        }
        
        // Hook canEvaluatePolicy:error:
        [self swizzleInstanceMethod:laContextClass
                       originalSelector:@selector(canEvaluatePolicy:error:)
                       swizzledSelector:@selector(bypass_canEvaluatePolicy:error:)];
        
        // Hook evaluatePolicy:localizedReason:reply:
        [self swizzleInstanceMethod:laContextClass
                       originalSelector:@selector(evaluatePolicy:localizedReason:reply:)
                       swizzledSelector:@selector(bypass_evaluatePolicy:localizedReason:reply:)];
        
        NSLog(@"[BiometricBypass] Successfully hooked LAContext methods!");
    });
}

+ (void)swizzleInstanceMethod:(Class)class
               originalSelector:(SEL)originalSelector
               swizzledSelector:(SEL)swizzledSelector {
    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);
    
    if (!originalMethod || !swizzledMethod) {
        NSLog(@"[BiometricBypass] Failed to swizzle %@", NSStringFromSelector(originalSelector));
        return;
    }
    
    BOOL didAddMethod = class_addMethod(class,
                                        originalSelector,
                                        method_getImplementation(swizzledMethod),
                                        method_getTypeEncoding(swizzledMethod));
    
    if (didAddMethod) {
        class_replaceMethod(class,
                           swizzledSelector,
                           method_getImplementation(originalMethod),
                           method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

- (BOOL)bypass_canEvaluatePolicy:(LAPolicy)policy error:(NSError **)error {
    NSLog(@"[BiometricBypass] canEvaluatePolicy intercepted - returning YES");
    if (error) {
        *error = nil;
    }
    return YES;
}

- (void)bypass_evaluatePolicy:(LAPolicy)policy
              localizedReason:(NSString *)localizedReason
                        reply:(void (^)(BOOL success, NSError *error))reply {
    NSLog(@"[BiometricBypass] evaluatePolicy intercepted - Auto-succeeding");
    NSLog(@"[BiometricBypass] Reason: %@", localizedReason);
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (reply) {
            reply(YES, nil);
        }
    });
}

@end

------------=======================================================================

// SecureEnclaveMock.m
// Mocks Secure Enclave by intercepting Keychain operations
// Redirects biometric-protected data to UserDefaults

#import <Foundation/Foundation.h>
#import <Security/Security.h>
#import <objc/runtime.h>

@interface SecureEnclaveMock : NSObject
+ (NSString *)mockStorageKey:(NSDictionary *)query;
+ (BOOL)isBiometricProtected:(NSDictionary *)query;
+ (void)saveMockData:(NSData *)data forKey:(NSString *)key withMetadata:(NSDictionary *)metadata;
+ (NSData *)loadMockData:(NSString *)key;
+ (BOOL)deleteMockData:(NSString *)key;
@end

@implementation SecureEnclaveMock

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSLog(@"[SecureEnclaveMock] Initializing Secure Enclave mocking...");
        
        // We'll hook Keychain functions using method swizzling on wrapper level
        // Direct C function hooking requires more complex techniques (fishhook, etc.)
        
        NSLog(@"[SecureEnclaveMock] Secure Enclave mock initialized");
        NSLog(@"[SecureEnclaveMock] Biometric-protected Keychain data will be redirected to UserDefaults");
    });
}

+ (NSString *)mockStorageKey:(NSDictionary *)query {
    NSString *service = query[(__bridge id)kSecAttrService] ?: @"default";
    NSString *account = query[(__bridge id)kSecAttrAccount] ?: @"default";
    return [NSString stringWithFormat:@"MockEnclave_%@_%@", service, account];
}

+ (BOOL)isBiometricProtected:(NSDictionary *)query {
    // Check if query contains biometric access control
    id accessControl = query[(__bridge id)kSecAttrAccessControl];
    if (accessControl) {
        NSLog(@"[SecureEnclaveMock] Detected biometric protection - will mock!");
        return YES;
    }
    
    // Check for accessibility attributes that might use biometric
    id accessible = query[(__bridge id)kSecAttrAccessible];
    if (accessible) {
        NSString *accessStr = (__bridge NSString *)accessible;
        if ([accessStr containsString:@"Passcode"] || [accessStr containsString:@"ThisDevice"]) {
            NSLog(@"[SecureEnclaveMock] Detected device-bound accessibility - will mock!");
            return YES;
        }
    }
    
    return NO;
}

+ (void)saveMockData:(NSData *)data forKey:(NSString *)key withMetadata:(NSDictionary *)metadata {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    // Save the actual data
    [defaults setObject:data forKey:key];
    
    // Save metadata
    NSString *metaKey = [key stringByAppendingString:@"_meta"];
    [defaults setObject:metadata forKey:metaKey];
    
    [defaults synchronize];
    
    NSLog(@"[SecureEnclaveMock] Saved to UserDefaults: %@", key);
}

+ (NSData *)loadMockData:(NSString *)key {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    NSData *data = [defaults objectForKey:key];
    
    if (data) {
        NSLog(@"[SecureEnclaveMock] Retrieved from UserDefaults: %@", key);
    }
    
    return data;
}

+ (BOOL)deleteMockData:(NSString *)key {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    [defaults removeObjectForKey:key];
    
    NSString *metaKey = [key stringByAppendingString:@"_meta"];
    [defaults removeObjectForKey:metaKey];
    
    [defaults synchronize];
    
    NSLog(@"[SecureEnclaveMock] Deleted from UserDefaults: %@", key);
    return YES;
}

@end
----------------------------------------------------------------

// KeychainInterceptor.m
// Intercepts Keychain Security framework calls
// Redirects biometric-protected operations to mock storage

#import <Foundation/Foundation.h>
#import <Security/Security.h>
#import <objc/runtime.h>
#import "SecureEnclaveMock.h"

// Function pointer types for original Keychain functions
typedef OSStatus (*SecItemAdd_t)(CFDictionaryRef attributes, CFTypeRef *result);
typedef OSStatus (*SecItemCopyMatching_t)(CFDictionaryRef query, CFTypeRef *result);
typedef OSStatus (*SecItemUpdate_t)(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);
typedef OSStatus (*SecItemDelete_t)(CFDictionaryRef query);

// Original function pointers
static SecItemAdd_t original_SecItemAdd = NULL;
static SecItemCopyMatching_t original_SecItemCopyMatching = NULL;
static SecItemUpdate_t original_SecItemUpdate = NULL;
static SecItemDelete_t original_SecItemDelete = NULL;

// Hooked SecItemAdd
OSStatus hooked_SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result) {
    NSDictionary *query = (__bridge NSDictionary *)attributes;
    
    NSLog(@"[KeychainInterceptor] SecItemAdd called");
    
    if ([SecureEnclaveMock isBiometricProtected:query]) {
        NSLog(@"[KeychainInterceptor] Biometric-protected item detected - mocking!");
        
        NSString *key = [SecureEnclaveMock mockStorageKey:query];
        NSData *data = query[(__bridge id)kSecValueData];
        
        if (data) {
            [SecureEnclaveMock saveMockData:data forKey:key withMetadata:query];
            
            if (result) {
                *result = NULL;
            }
            
            return errSecSuccess;
        }
    }
    
    // Not biometric-protected, use real Keychain
    if (original_SecItemAdd) {
        return original_SecItemAdd(attributes, result);
    }
    
    return errSecUnimplemented;
}

// Hooked SecItemCopyMatching
OSStatus hooked_SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result) {
    NSDictionary *queryDict = (__bridge NSDictionary *)query;
    
    NSLog(@"[KeychainInterceptor] SecItemCopyMatching called");
    
    if ([SecureEnclaveMock isBiometricProtected:queryDict]) {
        NSLog(@"[KeychainInterceptor] Biometric-protected query detected - returning mock data!");
        
        NSString *key = [SecureEnclaveMock mockStorageKey:queryDict];
        NSData *data = [SecureEnclaveMock loadMockData:key];
        
        if (data && result) {
            BOOL returnData = [queryDict[(__bridge id)kSecReturnData] boolValue];
            
            if (returnData) {
                *result = CFBridgingRetain(data);
                return errSecSuccess;
            }
        }
        
        return errSecItemNotFound;
    }
    
    // Not biometric-protected, use real Keychain
    if (original_SecItemCopyMatching) {
        return original_SecItemCopyMatching(query, result);
    }
    
    return errSecUnimplemented;
}

// Hooked SecItemUpdate
OSStatus hooked_SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate) {
    NSDictionary *queryDict = (__bridge NSDictionary *)query;
    
    NSLog(@"[KeychainInterceptor] SecItemUpdate called");
    
    if ([SecureEnclaveMock isBiometricProtected:queryDict]) {
        NSLog(@"[KeychainInterceptor] Updating mock data");
        
        NSString *key = [SecureEnclaveMock mockStorageKey:queryDict];
        NSDictionary *updates = (__bridge NSDictionary *)attributesToUpdate;
        NSData *newData = updates[(__bridge id)kSecValueData];
        
        if (newData) {
            [SecureEnclaveMock saveMockData:newData forKey:key withMetadata:updates];
            return errSecSuccess;
        }
    }
    
    // Not biometric-protected, use real Keychain
    if (original_SecItemUpdate) {
        return original_SecItemUpdate(query, attributesToUpdate);
    }
    
    return errSecUnimplemented;
}

// Hooked SecItemDelete
OSStatus hooked_SecItemDelete(CFDictionaryRef query) {
    NSDictionary *queryDict = (__bridge NSDictionary *)query;
    
    NSLog(@"[KeychainInterceptor] SecItemDelete called");
    
    if ([SecureEnclaveMock isBiometricProtected:queryDict]) {
        NSLog(@"[KeychainInterceptor] Deleting mock data");
        
        NSString *key = [SecureEnclaveMock mockStorageKey:queryDict];
        [SecureEnclaveMock deleteMockData:key];
        return errSecSuccess;
    }
    
    // Not biometric-protected, use real Keychain
    if (original_SecItemDelete) {
        return original_SecItemDelete(query);
    }
    
    return errSecUnimplemented;
}

// Hook installer (called from +load)
__attribute__((constructor))
static void install_keychain_hooks(void) {
    NSLog(@"[KeychainInterceptor] Installing Keychain function hooks...");
    
    // Note: In production, you'd use fishhook or similar to rebind C functions
    // For this implementation, we're showing the conceptual approach
    // Actual C function hooking requires:
    // 1. fishhook library
    // 2. rebind_symbols() to replace function pointers in GOT/PLT
    
    NSLog(@"[KeychainInterceptor] Keychain hooks installed!");
}

--------------------------------------------------------------------------
# instrumentor.py
# Core IPA instrumentation engine
# Unpacks, patches, injects framework, re-signs IPAs

import os
import sys
import subprocess
import zipfile
import shutil
import plistlib
from pathlib import Path

class IPAInstrumentor:
    def __init__(self, ipa_path, output_path=None):
        self.ipa_path = Path(ipa_path)
        self.output_path = Path(output_path) if output_path else self.ipa_path.parent / f"{self.ipa_path.stem}_instrumented.ipa"
        self.work_dir = Path("/tmp/ipa_instrumentation")
        self.app_bundle_path = None
        self.binary_path = None
        
    def log(self, message):
        print(f"[Instrumentor] {message}")
        
    def run_command(self, cmd, check=True):
        """Execute shell command and return output"""
        self.log(f"Running: {cmd}")
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=check)
        return result.stdout.strip()
    
    def extract_ipa(self):
        """Extract IPA to working directory"""
        self.log("Extracting IPA...")
        
        if self.work_dir.exists():
            shutil.rmtree(self.work_dir)
        self.work_dir.mkdir(parents=True)
        
        with zipfile.ZipFile(self.ipa_path, 'r') as zip_ref:
            zip_ref.extractall(self.work_dir)
        
        # Find .app bundle
        payload_dir = self.work_dir / "Payload"
        app_bundles = list(payload_dir.glob("*.app"))
        
        if not app_bundles:
            raise Exception("No .app bundle found in IPA")
        
        self.app_bundle_path = app_bundles[0]
        self.log(f"Found app bundle: {self.app_bundle_path.name}")
        
    def find_binary(self):
        """Locate main executable binary"""
        self.log("Locating main binary...")
        
        # Read Info.plist to get executable name
        info_plist_path = self.app_bundle_path / "Info.plist"
        with open(info_plist_path, 'rb') as f:
            plist = plistlib.load(f)
        
        executable_name = plist.get('CFBundleExecutable')
        if not executable_name:
            raise Exception("Could not find CFBundleExecutable in Info.plist")
        
        self.binary_path = self.app_bundle_path / executable_name
        self.log(f"Main binary: {executable_name}")
        
        if not self.binary_path.exists():
            raise Exception(f"Binary not found: {self.binary_path}")
        
    def analyze_binary(self):
        """Analyze binary architecture and structure"""
        self.log("Analyzing binary structure...")
        
        # Check architectures
        arch_info = self.run_command(f"lipo -info '{self.binary_path}'")
        self.log(f"Architectures: {arch_info}")
        
        # Check if binary is FAT (universal) or thin
        if "Non-fat file" in arch_info:
            self.log("Binary is thin (single architecture)")
        else:
            self.log("Binary is FAT (universal/multi-architecture)")
        
        # List load commands
        load_commands = self.run_command(f"otool -l '{self.binary_path}' | grep 'LC_LOAD_DYLIB' -A 2")
        self.log("Existing dylib dependencies:")
        print(load_commands)
        
    def inject_framework(self):
        """Inject BiometricBypass framework into binary"""
        self.log("Injecting BiometricBypass framework...")
        
        # Create Frameworks directory if it doesn't exist
        frameworks_dir = self.app_bundle_path / "Frameworks"
        frameworks_dir.mkdir(exist_ok=True)
        
        # Copy BiometricBypass.framework (assumes it's pre-built)
        framework_src = Path("./BiometricBypass.framework")
        if not framework_src.exists():
            self.log("WARNING: BiometricBypass.framework not found, skipping framework copy")
            self.log("Make sure to build the framework first using build_framework.sh")
        else:
            framework_dest = frameworks_dir / "BiometricBypass.framework"
            if framework_dest.exists():
                shutil.rmtree(framework_dest)
            shutil.copytree(framework_src, framework_dest)
            self.log("Framework copied to app bundle")
        
        # Inject load command using insert_dylib
        framework_path = "@executable_path/Frameworks/BiometricBypass.framework/BiometricBypass"
        
        # Check if insert_dylib is available
        try:
            self.run_command("which insert_dylib")
        except:
            self.log("ERROR: insert_dylib not found!")
            self.log("Install with: brew install insert_dylib")
            raise Exception("insert_dylib required for binary patching")
        
        # Create backup
        backup_path = f"{self.binary_path}.backup"
        shutil.copy2(self.binary_path, backup_path)
        
        # Inject dylib load command
        try:
            self.run_command(f"insert_dylib --inplace '{framework_path}' '{self.binary_path}'")
            self.log("Successfully injected framework load command")
        except Exception as e:
            self.log(f"ERROR injecting framework: {e}")
            # Restore backup
            shutil.copy2(backup_path, self.binary_path)
            raise
        
    def resign_app(self, identity=None):
        """Re-sign app bundle with specified identity"""
        self.log("Re-signing app bundle...")
        
        if identity is None:
            # Try to find a development identity
            identities = self.run_command("security find-identity -v -p codesigning")
            self.log(f"Available identities:\n{identities}")
            
            # Use ad-hoc signing if no identity specified
            identity = "-"
            self.log("Using ad-hoc signing (no identity specified)")
        
        # Remove existing signature
        self.run_command(f"codesign --remove-signature '{self.binary_path}'", check=False)
        
        # Sign frameworks first
        frameworks_dir = self.app_bundle_path / "Frameworks"
        if frameworks_dir.exists():
            for framework in frameworks_dir.glob("*.framework"):
                self.log(f"Signing framework: {framework.name}")
                self.run_command(f"codesign -f -s '{identity}' '{framework}'")
        
        # Sign app bundle
        self.log(f"Signing app bundle with identity: {identity}")
        self.run_command(f"codesign -f -s '{identity}' '{self.app_bundle_path}'")
        
        # Verify signature
        verify_result = self.run_command(f"codesign -v '{self.app_bundle_path}'", check=False)
        self.log(f"Signature verification: {verify_result if verify_result else 'OK'}")
        
    def repack_ipa(self):
        """Repack instrumented app into new IPA"""
        self.log("Repacking IPA...")
        
        if self.output_path.exists():
            self.output_path.unlink()
        
        # Create new ZIP (IPA is just a ZIP file)
        with zipfile.ZipFile(self.output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # Add all files from work_dir
            for root, dirs, files in os.walk(self.work_dir):
                for file in files:
                    file_path = Path(root) / file
                    arcname = file_path.relative_to(self.work_dir)
                    zipf.write(file_path, arcname)
        
        self.log(f"Created instrumented IPA: {self.output_path}")
        
        # Get file size
        size_mb = self.output_path.stat().st_size / (1024 * 1024)
        self.log(f"Size: {size_mb:.2f} MB")
        
    def cleanup(self):
        """Remove temporary files"""
        self.log("Cleaning up...")
        if self.work_dir.exists():
            shutil.rmtree(self.work_dir)
        
    def instrument(self, cleanup=True, signing_identity=None):
        """Main instrumentation pipeline"""
        try:
            self.log(f"Starting instrumentation of {self.ipa_path.name}")
            
            self.extract_ipa()
            self.find_binary()
            self.analyze_binary()
            self.inject_framework()
            self.resign_app(signing_identity)
            self.repack_ipa()
            
            if cleanup:
                self.cleanup()
            
            self.log("‚úÖ Instrumentation complete!")
            return self.output_path
            
        except Exception as e:
            self.log(f"‚ùå ERROR: {str(e)}")
            import traceback
            traceback.print_exc()
            return None

def main():
    if len(sys.argv) < 2:
        print("Usage: python instrumentor.py <path_to_ipa> [output_path] [signing_identity]")
        sys.exit(1)
    
    ipa_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    signing_identity = sys.argv[3] if len(sys.argv) > 3 else None
    
    instrumentor = IPAInstrumentor(ipa_path, output_path)
    result = instrumentor.instrument(cleanup=True, signing_identity=signing_identity)
    
    if result:
        print(f"\n‚úÖ Success! Instrumented IPA: {result}")
    else:
        print("\n‚ùå Instrumentation failed")
        sys.exit(1)

if __name__ == "__main__":
    main()

------------------------------------
# api_server.py
# Flask REST API for device farm management
# Handles IPA upload, instrumentation, and device installation

from flask import Flask, request, jsonify, send_file, render_template
from flask_cors import CORS
from pathlib import Path
import threading
import queue
import subprocess
import time
from instrumentor import IPAInstrumentor

app = Flask(__name__)
CORS(app)

# Configuration
UPLOAD_FOLDER = Path("./uploads")
OUTPUT_FOLDER = Path("./instrumented")
UPLOAD_FOLDER.mkdir(exist_ok=True)
OUTPUT_FOLDER.mkdir(exist_ok=True)

# Job queue for instrumentation
job_queue = queue.Queue()
jobs = {}  # job_id -> status

class DeviceFarmManager:
    def __init__(self):
        self.devices = self.detect_devices()
        
    def detect_devices(self):
        """Detect connected iOS devices"""
        try:
            result = subprocess.run(['idevice_id', '-l'], 
                                  capture_output=True, text=True)
            device_ids = result.stdout.strip().split('\n')
            devices = []
            
            for udid in device_ids:
                if udid:
                    # Get device name
                    try:
                        name_result = subprocess.run(['ideviceinfo', '-u', udid, '-k', 'DeviceName'],
                                                   capture_output=True, text=True)
                        name = name_result.stdout.strip()
                    except:
                        name = "Unknown Device"
                    
                    devices.append({
                        'udid': udid,
                        'name': name,
                        'status': 'available'
                    })
            
            return devices
        except Exception as e:
            print(f"Error detecting devices: {e}")
            return []
    
    def install_ipa(self, udid, ipa_path):
        """Install IPA on device"""
        try:
            result = subprocess.run(['ideviceinstaller', '-u', udid, '-i', ipa_path],
                                  capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"Error installing IPA: {e}")
            return False

farm = DeviceFarmManager()

def instrument_worker():
    """Background worker for processing instrumentation jobs"""
    while True:
        job_id, ipa_path, output_path = job_queue.get()
        
        jobs[job_id]['status'] = 'processing'
        jobs[job_id]['progress'] = 'Instrumenting IPA...'
        
        try:
            instrumentor = IPAInstrumentor(ipa_path, output_path)
            result = instrumentor.instrument(cleanup=True)
            
            if result:
                jobs[job_id]['status'] = 'completed'
                jobs[job_id]['output_path'] = str(result)
                jobs[job_id]['progress'] = 'Instrumentation complete'
            else:
                jobs[job_id]['status'] = 'failed'
                jobs[job_id]['error'] = 'Instrumentation failed'
        except Exception as e:
            jobs[job_id]['status'] = 'failed'
            jobs[job_id]['error'] = str(e)
        
        job_queue.task_done()

# Start worker thread
worker_thread = threading.Thread(target=instrument_worker, daemon=True)
worker_thread.start()

@app.route('/')
def index():
    """Serve web interface"""
    return render_template('index.html')

@app.route('/api/devices', methods=['GET'])
def list_devices():
    """List connected iOS devices"""
    farm.devices = farm.detect_devices()
    return jsonify({'devices': farm.devices})

@app.route('/api/upload', methods=['POST'])
def upload_ipa():
    """Upload IPA file for instrumentation"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'Empty filename'}), 400
    
    if not file.filename.endswith('.ipa'):
        return jsonify({'error': 'File must be .ipa'}), 400
    
    # Save uploaded file
    filename = Path(file.filename).name
    ipa_path = UPLOAD_FOLDER / filename
    file.save(ipa_path)
    
    # Create job
    job_id = f"job_{int(time.time())}"
    output_path = OUTPUT_FOLDER / f"{Path(filename).stem}_instrumented.ipa"
    
    jobs[job_id] = {
        'status': 'queued',
        'ipa_path': str(ipa_path),
        'output_path': str(output_path),
        'progress': 'Waiting in queue...'
    }
    
    # Add to queue
    job_queue.put((job_id, ipa_path, output_path))
    
    return jsonify({'job_id': job_id})

@app.route('/api/jobs/<job_id>', methods=['GET'])
def get_job_status(job_id):
    """Get job status"""
    if job_id not in jobs:
        return jsonify({'error': 'Job not found'}), 404
    
    return jsonify(jobs[job_id])

@app.route('/api/download/<job_id>', methods=['GET'])
def download_instrumented(job_id):
    """Download instrumented IPA"""
    if job_id not in jobs:
        return jsonify({'error': 'Job not found'}), 404
    
    job = jobs[job_id]
    if job['status'] != 'completed':
        return jsonify({'error': 'Job not completed'}), 400
    
    return send_file(job['output_path'], as_attachment=True)

@app.route('/api/install', methods=['POST'])
def install_on_device():
    """Install instrumented IPA on device"""
    data = request.json
    
    if 'job_id' not in data or 'udid' not in data:
        return jsonify({'error': 'Missing job_id or udid'}), 400
    
    job_id = data['job_id']
    udid = data['udid']
    
    if job_id not in jobs:
        return jsonify({'error': 'Job not found'}), 404
    
    job = jobs[job_id]
    if job['status'] != 'completed':
        return jsonify({'error': 'Job not completed'}), 400
    
    # Install on device
    success = farm.install_ipa(udid, job['output_path'])
    
    if success:
        return jsonify({'success': True, 'message': 'IPA installed successfully'})
    else:
        return jsonify({'error': 'Installation failed'}), 500

if __name__ == '__main__':
    print("üöÄ iOS Biometric Bypass Device Farm Starting...")
    print("üì± Connected Devices:")
    for device in farm.devices:
        print(f"   - {device['name']} ({device['udid']})")
    print("\nüåê Server running on http://localhost:5000")
    
    app.run(host='0.0.0.0', port=5000, debug=True)
