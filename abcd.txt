#!/bin/bash

# iOS Trace Symbolication Script with Framework Support
# Compatible with Xcode 16 and later
# Usage: ./symbolicate_trace.sh <trace_file> <dsym_directory> [output_file]

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if required tools are available
check_requirements() {
    print_status "Checking requirements..."
    
    if ! command -v xcrun &> /dev/null; then
        print_error "xcrun not found. Please ensure Xcode is installed."
        exit 1
    fi
    
    # Check Xcode version
    local xcode_version=$(xcodebuild -version | head -n 1 | grep -oE '[0-9]+\.[0-9]+')
    local major_version=$(echo $xcode_version | cut -d. -f1)
    
    if [[ $major_version -lt 16 ]]; then
        print_warning "Xcode version $xcode_version detected. This script is optimized for Xcode 16+."
    else
        print_success "Xcode version $xcode_version detected."
    fi
    
    # Check if xctrace is available
    if ! xcrun xctrace help &> /dev/null; then
        print_error "xctrace not available. Please ensure you have Xcode Command Line Tools installed."
        exit 1
    fi
    
    print_success "All requirements met."
}

# Function to find all dSYM files recursively including system frameworks
find_dsym_files() {
    local dsym_dir="$1"
    local dsym_files=()
    
    print_status "Searching for dSYM files in: $dsym_dir"
    
    # Find all .dSYM bundles
    while IFS= read -r -d '' dsym_path; do
        if [[ -d "$dsym_path" ]]; then
            dsym_files+=("$dsym_path")
            print_status "Found dSYM: $(basename "$dsym_path")"
        fi
    done < <(find "$dsym_dir" -name "*.dSYM" -print0 2>/dev/null || true)
    
    # Also search in common system locations for iOS frameworks
    local system_paths=(
        "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport"
        "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/DeviceTypes"
        "$HOME/Library/Developer/Xcode/iOS DeviceSupport"
    )
    
    for sys_path in "${system_paths[@]}"; do
        if [[ -d "$sys_path" ]]; then
            print_status "Searching system path: $sys_path"
            while IFS= read -r -d '' dsym_path; do
                if [[ -d "$dsym_path" ]]; then
                    dsym_files+=("$dsym_path")
                    print_status "Found system dSYM: $(basename "$dsym_path")"
                fi
            done < <(find "$sys_path" -name "*.dSYM" -print0 2>/dev/null || true)
        fi
    done
    
    if [[ ${#dsym_files[@]} -eq 0 ]]; then
        print_warning "No dSYM files found in $dsym_dir"
        return 1
    fi
    
    printf '%s\n' "${dsym_files[@]}"
    return 0
}

# Function to get UUID from dSYM with multiple attempts
get_dsym_uuid() {
    local dsym_path="$1"
    local uuid_info=""
    local binary_name=""
    
    # Get the expected binary name from dSYM bundle name
    binary_name=$(basename "$dsym_path" .dSYM)
    
    # Method 1: Try dwarfdump on the bundle directly
    uuid_info=$(xcrun dwarfdump --uuid "$dsym_path" 2>/dev/null | grep -E '^UUID:' | head -n 1 | awk '{print $2}' || echo "")
    
    if [[ -z "$uuid_info" ]]; then
        # Method 2: Try to find the actual binary inside the dSYM
        local dwarf_dir="$dsym_path/Contents/Resources/DWARF"
        if [[ -d "$dwarf_dir" ]]; then
            # Try the expected binary name first
            if [[ -f "$dwarf_dir/$binary_name" ]]; then
                uuid_info=$(xcrun dwarfdump --uuid "$dwarf_dir/$binary_name" 2>/dev/null | grep -E '^UUID:' | head -n 1 | awk '{print $2}' || echo "")
            fi
            
            # If still empty, try all files in DWARF directory
            if [[ -z "$uuid_info" ]]; then
                for dwarf_file in "$dwarf_dir"/*; do
                    if [[ -f "$dwarf_file" ]]; then
                        uuid_info=$(xcrun dwarfdump --uuid "$dwarf_file" 2>/dev/null | grep -E '^UUID:' | head -n 1 | awk '{print $2}' || echo "")
                        if [[ -n "$uuid_info" ]]; then
                            break
                        fi
                    fi
                done
            fi
        fi
    fi
    
    # Method 3: Try using otool if dwarfdump fails
    if [[ -z "$uuid_info" ]] && [[ -d "$dsym_path/Contents/Resources/DWARF" ]]; then
        local dwarf_dir="$dsym_path/Contents/Resources/DWARF"
        for dwarf_file in "$dwarf_dir"/*; do
            if [[ -f "$dwarf_file" ]]; then
                uuid_info=$(xcrun otool -l "$dwarf_file" 2>/dev/null | grep -A3 LC_UUID | grep uuid | awk '{print $2}' || echo "")
                if [[ -n "$uuid_info" ]]; then
                    break
                fi
            fi
        done
    fi
    
    echo "$uuid_info"
}

# Function to validate dSYM file
validate_dsym() {
    local dsym_path="$1"
    
    # Check if dSYM bundle exists and has proper structure
    if [[ ! -d "$dsym_path" ]]; then
        return 1
    fi
    
    # Check if DWARF directory exists
    local dwarf_dir="$dsym_path/Contents/Resources/DWARF"
    if [[ ! -d "$dwarf_dir" ]]; then
        return 1
    fi
    
    # Check if there are DWARF files
    if [[ -z "$(ls -A "$dwarf_dir" 2>/dev/null)" ]]; then
        return 1
    fi
    
    return 0
}

# Function to create symbolication command
create_symbolication_args() {
    local trace_file="$1"
    local dsym_dir="$2"
    local -a symbolication_args=()
    local failed_dsyms=()
    
    # Add basic symbolication arguments
    symbolication_args+=("xctrace" "symbolicate")
    symbolication_args+=("--input" "$trace_file")
    
    print_status "Processing dSYM files..."
    
    # Find and validate all dSYM files
    local dsym_files
    if ! dsym_files=$(find_dsym_files "$dsym_dir"); then
        print_error "No valid dSYM files found."
        return 1
    fi
    
    # Process each dSYM file
    while IFS= read -r dsym_path; do
        if validate_dsym "$dsym_path"; then
            local uuid=$(get_dsym_uuid "$dsym_path")
            if [[ -n "$uuid" ]]; then
                symbolication_args+=("--dsym" "$dsym_path")
                print_success "Added dSYM: $(basename "$dsym_path") (UUID: $uuid)"
            else
                print_warning "Could not determine UUID for: $(basename "$dsym_path")"
                failed_dsyms+=("$dsym_path")
            fi
        else
            print_warning "Invalid dSYM structure: $(basename "$dsym_path")"
            failed_dsyms+=("$dsym_path")
        fi
    done <<< "$dsym_files"
    
    # Report failed dSYMs
    if [[ ${#failed_dsyms[@]} -gt 0 ]]; then
        print_warning "Skipped ${#failed_dsyms[@]} invalid dSYM files:"
        for failed_dsym in "${failed_dsyms[@]}"; do
            print_warning "  - $(basename "$failed_dsym")"
        done
    fi
    
    printf '%s\n' "${symbolication_args[@]}"
    return 0
}

# Alternative symbolication method using atos for stubborn traces
symbolicate_with_atos() {
    local trace_file="$1"
    local dsym_dir="$2"
    local output_file="$3"
    
    print_status "Attempting alternative symbolication using atos method..."
    
    # First try to export the trace to a more processable format
    local temp_dir=$(mktemp -d)
    local exported_trace="$temp_dir/exported.txt"
    
    # Try to export trace data
    if xcrun xctrace export --input "$trace_file" --output "$exported_trace" 2>/dev/null; then
        print_status "Successfully exported trace for processing"
        
        # Now try to process with symbolication
        local dsym_files
        if ! dsym_files=$(find_dsym_files "$dsym_dir"); then
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Build comprehensive dsym arguments
        local -a dsym_args=()
        while IFS= read -r dsym_path; do
            if validate_dsym "$dsym_path"; then
                dsym_args+=("--dsym" "$dsym_path")
            fi
        done <<< "$dsym_files"
        
        # Try symbolication again with exported data
        if [[ ${#dsym_args[@]} -gt 0 ]]; then
            local final_output="${output_file:-/dev/stdout}"
            if xcrun xctrace symbolicate --input "$trace_file" "${dsym_args[@]}" --output "$final_output" 2>/dev/null; then
                print_success "Alternative symbolication successful!"
                rm -rf "$temp_dir"
                return 0
            fi
        fi
    fi
    
    rm -rf "$temp_dir"
    return 1
}

# Function to perform symbolication with multiple retry strategies
symbolicate_trace() {
    local trace_file="$1"
    local dsym_dir="$2"
    local output_file="$3"
    local -a cmd_args=()
    
    print_status "Starting symbolication process..."
    
    # Method 1: Standard symbolication
    if ! mapfile -t cmd_args < <(create_symbolication_args "$trace_file" "$dsym_dir"); then
        print_warning "Failed to create symbolication arguments, trying alternative methods..."
    else
        # Add output file if specified
        if [[ -n "$output_file" ]]; then
            cmd_args+=("--output" "$output_file")
        fi
        
        print_status "Executing symbolication command..."
        print_status "Command: xcrun ${cmd_args[*]:1}"
        
        # Execute symbolication with error handling
        if xcrun "${cmd_args[@]:1}" 2>&1; then
            print_success "Symbolication completed successfully!"
            return 0
        else
            print_warning "Standard symbolication failed, trying alternative methods..."
        fi
    fi
    
    # Method 2: Alternative symbolication
    if symbolicate_with_atos "$trace_file" "$dsym_dir" "$output_file"; then
        return 0
    fi
    
    # Method 3: Forced symbolication without UUID validation
    print_status "Attempting forced symbolication (ignoring UUID mismatches)..."
    local -a force_args=("xctrace" "symbolicate" "--input" "$trace_file")
    
    local dsym_files
    if dsym_files=$(find_dsym_files "$dsym_dir"); then
        while IFS= read -r dsym_path; do
            if [[ -d "$dsym_path" ]]; then
                force_args+=("--dsym" "$dsym_path")
                print_status "Force-adding dSYM: $(basename "$dsym_path")"
            fi
        done <<< "$dsym_files"
        
        if [[ -n "$output_file" ]]; then
            force_args+=("--output" "$output_file")
        fi
        
        print_status "Force command: xcrun ${force_args[*]:1}"
        if xcrun "${force_args[@]:1}" 2>&1; then
            print_success "Forced symbolication completed!"
            return 0
        fi
    fi
    
    print_error "All symbolication methods failed!"
    return 1
}

# Function to analyze trace file
analyze_trace() {
    local trace_file="$1"
    
    print_status "Analyzing trace file: $trace_file"
    
    if [[ ! -f "$trace_file" ]]; then
        print_error "Trace file not found: $trace_file"
        return 1
    fi
    
    # Get trace file info
    local file_size=$(du -h "$trace_file" | cut -f1)
    print_status "Trace file size: $file_size"
    
    # Try to get basic trace information
    if xcrun xctrace help export &> /dev/null; then
        print_status "Trace appears to be valid."
    fi
    
    return 0
}

# Function to show usage
show_usage() {
    cat << EOF
iOS Trace Symbolication Script

USAGE:
    $0 <trace_file> <dsym_directory> [output_file]

ARGUMENTS:
    trace_file      Path to the .trace file to symbolicate
    dsym_directory  Directory containing .dSYM files (searched recursively)
    output_file     Optional output file path (if not specified, outputs to stdout)

EXAMPLES:
    # Basic symbolication with output to stdout
    $0 MyApp.trace ./dSYMs

    # Symbolication with specific output file
    $0 MyApp.trace ./dSYMs symbolicated_trace.trace

    # Using with app launch automation
    xcrun xctrace record --template 'App Launch' --target-stdin - --output launch.trace
    $0 launch.trace ./Build/Products/Debug-iphoneos/ symbolicated_launch.trace

    # For problematic framework symbolication, try multiple dSYM paths:
    $0 MyApp.trace "./dSYMs:./Frameworks:./SystemFrameworks" output.trace

TROUBLESHOOTING:
    If symbolication fails with frameworks:
    1. Ensure all framework dSYMs are in the search directory
    2. Check that dSYM UUIDs match the binary UUIDs in your trace
    3. Try running with multiple search paths separated by colons
    4. The script will attempt multiple symbolication strategies automatically

FEATURES:
    - Recursively finds all .dSYM files in the specified directory
    - Searches system framework locations automatically
    - Validates dSYM files before processing with multiple UUID extraction methods
    - Supports both app and framework dSYM files
    - Multiple fallback symbolication strategies for stubborn traces
    - Gracefully handles invalid or corrupted dSYM files
    - Provides detailed logging and error reporting
    - Compatible with Xcode 16+ tools

EOF
}

# Main function
main() {
    echo "iOS Trace Symbolication Script v1.0"
    echo "===================================="
    
    # Check arguments
    if [[ $# -lt 2 || $# -gt 3 ]]; then
        show_usage
        exit 1
    fi
    
    local trace_file="$1"
    local dsym_dir="$2"
    local output_file="${3:-}"
    
    # Validate inputs
    if [[ ! -f "$trace_file" ]]; then
        print_error "Trace file not found: $trace_file"
        exit 1
    fi
    
    if [[ ! -d "$dsym_dir" ]]; then
        print_error "dSYM directory not found: $dsym_dir"
        exit 1
    fi
    
    # Check requirements
    check_requirements
    
    # Analyze trace file
    analyze_trace "$trace_file"
    
    # Perform symbolication
    if symbolicate_trace "$trace_file" "$dsym_dir" "$output_file"; then
        print_success "All operations completed successfully!"
        exit 0
    else
        print_error "Symbolication failed!"
        exit 1
    fi
}

# Execute main function with all arguments
main "$@"