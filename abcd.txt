#!/bin/bash

# iOS Trace Symbolication Script with Framework Support

# Compatible with Xcode 16 and later

# Usage: ./symbolicate_trace.sh <trace_file> <dsym_directory> [output_file]

set -euo pipefail

# Colors for output

RED=’\033[0;31m’
GREEN=’\033[0;32m’
YELLOW=’\033[1;33m’
BLUE=’\033[0;34m’
NC=’\033[0m’ # No Color

# Function to print colored output

print_status() {
echo -e “${BLUE}[INFO]${NC} $1”
}

print_success() {
echo -e “${GREEN}[SUCCESS]${NC} $1”
}

print_warning() {
echo -e “${YELLOW}[WARNING]${NC} $1”
}

print_error() {
echo -e “${RED}[ERROR]${NC} $1”
}

# Function to check if required tools are available

check_requirements() {
print_status “Checking requirements…”

```
if ! command -v xcrun &> /dev/null; then
    print_error "xcrun not found. Please ensure Xcode is installed."
    exit 1
fi

# Check Xcode version
local xcode_version=$(xcodebuild -version | head -n 1 | grep -oE '[0-9]+\.[0-9]+')
local major_version=$(echo $xcode_version | cut -d. -f1)

if [[ $major_version -lt 16 ]]; then
    print_warning "Xcode version $xcode_version detected. This script is optimized for Xcode 16+."
else
    print_success "Xcode version $xcode_version detected."
fi

# Check if xctrace is available
if ! xcrun xctrace help &> /dev/null; then
    print_error "xctrace not available. Please ensure you have Xcode Command Line Tools installed."
    exit 1
fi

print_success "All requirements met."
```

}

# Function to find all dSYM files recursively

find_dsym_files() {
local dsym_dir=”$1”
local dsym_files=()

```
print_status "Searching for dSYM files in: $dsym_dir"

# Find all .dSYM bundles
while IFS= read -r -d '' dsym_path; do
    if [[ -d "$dsym_path" ]]; then
        dsym_files+=("$dsym_path")
        print_status "Found dSYM: $(basename "$dsym_path")"
    fi
done < <(find "$dsym_dir" -name "*.dSYM" -print0 2>/dev/null || true)

if [[ ${#dsym_files[@]} -eq 0 ]]; then
    print_warning "No dSYM files found in $dsym_dir"
    return 1
fi

printf '%s\n' "${dsym_files[@]}"
return 0
```

}

# Function to get UUID from dSYM

get_dsym_uuid() {
local dsym_path=”$1”
local uuid_info

```
# Try to get UUID using dwarfdump
uuid_info=$(xcrun dwarfdump --uuid "$dsym_path" 2>/dev/null | head -n 1 | awk '{print $2}' || echo "")

if [[ -z "$uuid_info" ]]; then
    # Fallback: try to find binary inside dSYM and get its UUID
    local binary_path=$(find "$dsym_path" -type f -perm +111 | head -n 1)
    if [[ -n "$binary_path" ]]; then
        uuid_info=$(xcrun dwarfdump --uuid "$binary_path" 2>/dev/null | head -n 1 | awk '{print $2}' || echo "")
    fi
fi

echo "$uuid_info"
```

}

# Function to validate dSYM file

validate_dsym() {
local dsym_path=”$1”

```
# Check if dSYM bundle exists and has proper structure
if [[ ! -d "$dsym_path" ]]; then
    return 1
fi

# Check if DWARF directory exists
local dwarf_dir="$dsym_path/Contents/Resources/DWARF"
if [[ ! -d "$dwarf_dir" ]]; then
    return 1
fi

# Check if there are DWARF files
if [[ -z "$(ls -A "$dwarf_dir" 2>/dev/null)" ]]; then
    return 1
fi

return 0
```

}

# Function to create symbolication command

create_symbolication_args() {
local trace_file=”$1”
local dsym_dir=”$2”
local -a symbolication_args=()
local failed_dsyms=()

```
# Add basic symbolication arguments
symbolication_args+=("xctrace" "symbolicate")
symbolication_args+=("--input" "$trace_file")

print_status "Processing dSYM files..."

# Find and validate all dSYM files
local dsym_files
if ! dsym_files=$(find_dsym_files "$dsym_dir"); then
    print_error "No valid dSYM files found."
    return 1
fi

# Process each dSYM file
while IFS= read -r dsym_path; do
    if validate_dsym "$dsym_path"; then
        local uuid=$(get_dsym_uuid "$dsym_path")
        if [[ -n "$uuid" ]]; then
            symbolication_args+=("--dsym" "$dsym_path")
            print_success "Added dSYM: $(basename "$dsym_path") (UUID: $uuid)"
        else
            print_warning "Could not determine UUID for: $(basename "$dsym_path")"
            failed_dsyms+=("$dsym_path")
        fi
    else
        print_warning "Invalid dSYM structure: $(basename "$dsym_path")"
        failed_dsyms+=("$dsym_path")
    fi
done <<< "$dsym_files"

# Report failed dSYMs
if [[ ${#failed_dsyms[@]} -gt 0 ]]; then
    print_warning "Skipped ${#failed_dsyms[@]} invalid dSYM files:"
    for failed_dsym in "${failed_dsyms[@]}"; do
        print_warning "  - $(basename "$failed_dsym")"
    done
fi

printf '%s\n' "${symbolication_args[@]}"
return 0
```

}

# Function to perform symbolication with retry logic

symbolicate_trace() {
local trace_file=”$1”
local dsym_dir=”$2”
local output_file=”$3”
local -a cmd_args=()

```
print_status "Starting symbolication process..."

# Get symbolication command arguments
if ! mapfile -t cmd_args < <(create_symbolication_args "$trace_file" "$dsym_dir"); then
    return 1
fi

# Add output file if specified
if [[ -n "$output_file" ]]; then
    cmd_args+=("--output" "$output_file")
fi

print_status "Executing symbolication command..."
print_status "Command: xcrun ${cmd_args[*]:1}"

# Execute symbolication with error handling
local exit_code=0
if ! xcrun "${cmd_args[@]:1}" 2>&1; then
    exit_code=$?
    print_error "Symbolication failed with exit code: $exit_code"
    return $exit_code
fi

print_success "Symbolication completed successfully!"

if [[ -n "$output_file" ]]; then
    print_success "Symbolicated trace saved to: $output_file"
fi

return 0
```

}

# Function to analyze trace file

analyze_trace() {
local trace_file=”$1”

```
print_status "Analyzing trace file: $trace_file"

if [[ ! -f "$trace_file" ]]; then
    print_error "Trace file not found: $trace_file"
    return 1
fi

# Get trace file info
local file_size=$(du -h "$trace_file" | cut -f1)
print_status "Trace file size: $file_size"

# Try to get basic trace information
if xcrun xctrace help export &> /dev/null; then
    print_status "Trace appears to be valid."
fi

return 0
```

}

# Function to show usage

show_usage() {
cat << EOF
iOS Trace Symbolication Script

USAGE:
$0 <trace_file> <dsym_directory> [output_file]

ARGUMENTS:
trace_file      Path to the .trace file to symbolicate
dsym_directory  Directory containing .dSYM files (searched recursively)
output_file     Optional output file path (if not specified, outputs to stdout)

EXAMPLES:
# Basic symbolication with output to stdout
$0 MyApp.trace ./dSYMs

```
# Symbolication with specific output file
$0 MyApp.trace ./dSYMs symbolicated_trace.trace

# Using with app launch automation
xcrun xctrace record --template 'App Launch' --target-stdin - --output launch.trace
$0 launch.trace ./Build/Products/Debug-iphoneos/MyApp.app.dSYM symbolicated_launch.trace
```

FEATURES:
- Recursively finds all .dSYM files in the specified directory
- Validates dSYM files before processing
- Supports both app and framework dSYM files
- Gracefully handles invalid or corrupted dSYM files
- Provides detailed logging and error reporting
- Compatible with Xcode 16+ tools

EOF
}

# Main function

main() {
echo “iOS Trace Symbolication Script v1.0”
echo “====================================”

```
# Check arguments
if [[ $# -lt 2 || $# -gt 3 ]]; then
    show_usage
    exit 1
fi

local trace_file="$1"
local dsym_dir="$2"
local output_file="${3:-}"

# Validate inputs
if [[ ! -f "$trace_file" ]]; then
    print_error "Trace file not found: $trace_file"
    exit 1
fi

if [[ ! -d "$dsym_dir" ]]; then
    print_error "dSYM directory not found: $dsym_dir"
    exit 1
fi

# Check requirements
check_requirements

# Analyze trace file
analyze_trace "$trace_file"

# Perform symbolication
if symbolicate_trace "$trace_file" "$dsym_dir" "$output_file"; then
    print_success "All operations completed successfully!"
    exit 0
else
    print_error "Symbolication failed!"
    exit 1
fi
```

}

# Execute main function with all arguments

main “$@”