import argparse
import os
import subprocess
import json
import re
import logging

def extract_trace_uuids(trace_path):
    """
    Use 'xcrun xctrace export --format json' to extract UUIDs from the .trace file.
    """
    try:
        result = subprocess.run(
            ["xcrun", "xctrace", "export", "--input", trace_path, "--format", "json"],
            capture_output=True, text=True, check=True
        )
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to export trace to JSON: {e.stderr}")
        raise SystemExit(1)
    # Parse JSON output for any UUID fields (standard UUID pattern)
    uuids = set()
    try:
        data = json.loads(result.stdout)
        # Recursively search for uuid-like strings in JSON
        def find_uuids(node):
            if isinstance(node, dict):
                for k, v in node.items():
                    if isinstance(v, str) and re.match(r"^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-"
                                                       r"[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-"
                                                       r"[0-9A-Fa-f]{12}$", v):
                        uuids.add(v.upper())
                    else:
                        find_uuids(v)
            elif isinstance(node, list):
                for item in node:
                    find_uuids(item)
        find_uuids(data)
    except json.JSONDecodeError as e:
        logging.error(f"Invalid JSON from xctrace export: {e}")
        raise SystemExit(1)

    return uuids

def collect_dsym_uuids(dsym_folder):
    """
    Traverse the dsym folder, running dwarfdump on each .dSYM to collect UUIDs.
    Returns a mapping: uuid -> list of dsym paths that contain it.
    """
    dsym_map = {}
    for root, dirs, files in os.walk(dsym_folder):
        for name in dirs:
            if name.endswith(".dSYM"):
                dsym_path = os.path.join(root, name)
                # Run dwarfdump to get all UUIDs for this dSYM
                try:
                    result = subprocess.run(
                        ["xcrun", "dwarfdump", "--uuid", dsym_path],
                        capture_output=True, text=True, check=True
                    )
                except subprocess.CalledProcessError as e:
                    logging.warning(f"Failed to run dwarfdump on {dsym_path}: {e.stderr}")
                    continue
                for line in result.stdout.splitlines():
                    match = re.search(r"UUID:\s*([0-9A-Fa-f\-]+)", line)
                    if match:
                        uuid = match.group(1).upper()
                        dsym_map.setdefault(uuid, []).append(dsym_path)
    return dsym_map

def main():
    parser = argparse.ArgumentParser(
        description="Symbolicate an Instruments .trace using matching dSYM bundles."
    )
    parser.add_argument("trace", help="Path to the .trace file")
    parser.add_argument("dsym_folder", help="Folder containing .dSYM bundles")
    parser.add_argument("-o", "--output", help="Output path for symbolicated trace")
    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
    trace_path = args.trace
    dsym_folder = args.dsym_folder
    output_path = args.output or (os.path.splitext(trace_path)[0] + "_symbolicated.trace")

    # Check inputs
    if not os.path.isfile(trace_path):
        logging.error(f"Trace file not found: {trace_path}")
        return
    if not os.path.isdir(dsym_folder):
        logging.error(f"dSYM folder not found: {dsym_folder}")
        return

    logging.info(f"Extracting required UUIDs from trace: {trace_path}")
    required_uuids = extract_trace_uuids(trace_path)
    if not required_uuids:
        logging.warning("No UUIDs found in trace; nothing to symbolicate.")
        return

    logging.info(f"Collected {len(required_uuids)} UUID(s) from trace.")
    dsym_map = collect_dsym_uuids(dsym_folder)
    if not dsym_map:
        logging.warning("No .dSYM files found or no UUIDs extracted from them.")

    # Determine which UUIDs are satisfied by available dSYMs
    matched_dsyms = set()
    symbolicated_uuids = []
    missing_uuids = []

    for uuid in sorted(required_uuids):
        if uuid in dsym_map:
            # Mark all dsym paths for this uuid
            for dsym_path in dsym_map[uuid]:
                matched_dsyms.add(dsym_path)
            symbolicated_uuids.append(uuid)
        else:
            missing_uuids.append(uuid)

    if missing_uuids:
        logging.warning(f"UUIDs with no matching dSYM (skipped): {', '.join(missing_uuids)}")

    if not matched_dsyms:
        logging.error("No matching dSYM found for any UUID; aborting symbolication.")
        return

    # Run xctrace symbolicate with the matched dSYMs
    cmd = ["xcrun", "xctrace", "symbolicate", "--input", trace_path, "--output", output_path]
    for dsym_path in matched_dsyms:
        cmd.extend(["--dsym", dsym_path])
    logging.info(f"Running symbolicate with dSYM(s): {list(matched_dsyms)}")
    try:
        subprocess.run(cmd, check=True)
    except FileNotFoundError:
        logging.error("xcrun not found. Make sure Xcode command-line tools are installed.")
        return
    except subprocess.CalledProcessError as e:
        logging.error(f"Symbolication failed: {e}")
        return

    logging.info(f"Symbolication completed. Output saved to {output_path}")
    logging.info(f"UUIDs symbolicated: {', '.join(symbolicated_uuids)}")

if __name__ == "__main__":
    main()